// This file was generated by counterfeiter
package rcfakes

import (
	"crypto/tls"
	"sync"

	"github.com/concourse/fly/rc"
	"github.com/concourse/go-concourse/concourse"
)

type FakeTarget struct {
	ClientStub        func() concourse.Client
	clientMutex       sync.RWMutex
	clientArgsForCall []struct{}
	clientReturns     struct {
		result1 concourse.Client
	}
	TeamStub        func() concourse.Team
	teamMutex       sync.RWMutex
	teamArgsForCall []struct{}
	teamReturns     struct {
		result1 concourse.Team
	}
	CACertStub        func() string
	cACertMutex       sync.RWMutex
	cACertArgsForCall []struct{}
	cACertReturns     struct {
		result1 string
	}
	ValidateStub        func() error
	validateMutex       sync.RWMutex
	validateArgsForCall []struct{}
	validateReturns     struct {
		result1 error
	}
	ValidateWithWarningOnlyStub        func() error
	validateWithWarningOnlyMutex       sync.RWMutex
	validateWithWarningOnlyArgsForCall []struct{}
	validateWithWarningOnlyReturns     struct {
		result1 error
	}
	TLSConfigStub        func() *tls.Config
	tLSConfigMutex       sync.RWMutex
	tLSConfigArgsForCall []struct{}
	tLSConfigReturns     struct {
		result1 *tls.Config
	}
	URLStub        func() string
	uRLMutex       sync.RWMutex
	uRLArgsForCall []struct{}
	uRLReturns     struct {
		result1 string
	}
	TokenStub        func() *rc.TargetToken
	tokenMutex       sync.RWMutex
	tokenArgsForCall []struct{}
	tokenReturns     struct {
		result1 *rc.TargetToken
	}
	TokenAuthorizationStub        func() (string, bool)
	tokenAuthorizationMutex       sync.RWMutex
	tokenAuthorizationArgsForCall []struct{}
	tokenAuthorizationReturns     struct {
		result1 string
		result2 bool
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeTarget) Client() concourse.Client {
	fake.clientMutex.Lock()
	fake.clientArgsForCall = append(fake.clientArgsForCall, struct{}{})
	fake.recordInvocation("Client", []interface{}{})
	fake.clientMutex.Unlock()
	if fake.ClientStub != nil {
		return fake.ClientStub()
	} else {
		return fake.clientReturns.result1
	}
}

func (fake *FakeTarget) ClientCallCount() int {
	fake.clientMutex.RLock()
	defer fake.clientMutex.RUnlock()
	return len(fake.clientArgsForCall)
}

func (fake *FakeTarget) ClientReturns(result1 concourse.Client) {
	fake.ClientStub = nil
	fake.clientReturns = struct {
		result1 concourse.Client
	}{result1}
}

func (fake *FakeTarget) Team() concourse.Team {
	fake.teamMutex.Lock()
	fake.teamArgsForCall = append(fake.teamArgsForCall, struct{}{})
	fake.recordInvocation("Team", []interface{}{})
	fake.teamMutex.Unlock()
	if fake.TeamStub != nil {
		return fake.TeamStub()
	} else {
		return fake.teamReturns.result1
	}
}

func (fake *FakeTarget) TeamCallCount() int {
	fake.teamMutex.RLock()
	defer fake.teamMutex.RUnlock()
	return len(fake.teamArgsForCall)
}

func (fake *FakeTarget) TeamReturns(result1 concourse.Team) {
	fake.TeamStub = nil
	fake.teamReturns = struct {
		result1 concourse.Team
	}{result1}
}

func (fake *FakeTarget) CACert() string {
	fake.cACertMutex.Lock()
	fake.cACertArgsForCall = append(fake.cACertArgsForCall, struct{}{})
	fake.recordInvocation("CACert", []interface{}{})
	fake.cACertMutex.Unlock()
	if fake.CACertStub != nil {
		return fake.CACertStub()
	} else {
		return fake.cACertReturns.result1
	}
}

func (fake *FakeTarget) CACertCallCount() int {
	fake.cACertMutex.RLock()
	defer fake.cACertMutex.RUnlock()
	return len(fake.cACertArgsForCall)
}

func (fake *FakeTarget) CACertReturns(result1 string) {
	fake.CACertStub = nil
	fake.cACertReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTarget) Validate() error {
	fake.validateMutex.Lock()
	fake.validateArgsForCall = append(fake.validateArgsForCall, struct{}{})
	fake.recordInvocation("Validate", []interface{}{})
	fake.validateMutex.Unlock()
	if fake.ValidateStub != nil {
		return fake.ValidateStub()
	} else {
		return fake.validateReturns.result1
	}
}

func (fake *FakeTarget) ValidateCallCount() int {
	fake.validateMutex.RLock()
	defer fake.validateMutex.RUnlock()
	return len(fake.validateArgsForCall)
}

func (fake *FakeTarget) ValidateReturns(result1 error) {
	fake.ValidateStub = nil
	fake.validateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTarget) ValidateWithWarningOnly() error {
	fake.validateWithWarningOnlyMutex.Lock()
	fake.validateWithWarningOnlyArgsForCall = append(fake.validateWithWarningOnlyArgsForCall, struct{}{})
	fake.recordInvocation("ValidateWithWarningOnly", []interface{}{})
	fake.validateWithWarningOnlyMutex.Unlock()
	if fake.ValidateWithWarningOnlyStub != nil {
		return fake.ValidateWithWarningOnlyStub()
	} else {
		return fake.validateWithWarningOnlyReturns.result1
	}
}

func (fake *FakeTarget) ValidateWithWarningOnlyCallCount() int {
	fake.validateWithWarningOnlyMutex.RLock()
	defer fake.validateWithWarningOnlyMutex.RUnlock()
	return len(fake.validateWithWarningOnlyArgsForCall)
}

func (fake *FakeTarget) ValidateWithWarningOnlyReturns(result1 error) {
	fake.ValidateWithWarningOnlyStub = nil
	fake.validateWithWarningOnlyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTarget) TLSConfig() *tls.Config {
	fake.tLSConfigMutex.Lock()
	fake.tLSConfigArgsForCall = append(fake.tLSConfigArgsForCall, struct{}{})
	fake.recordInvocation("TLSConfig", []interface{}{})
	fake.tLSConfigMutex.Unlock()
	if fake.TLSConfigStub != nil {
		return fake.TLSConfigStub()
	} else {
		return fake.tLSConfigReturns.result1
	}
}

func (fake *FakeTarget) TLSConfigCallCount() int {
	fake.tLSConfigMutex.RLock()
	defer fake.tLSConfigMutex.RUnlock()
	return len(fake.tLSConfigArgsForCall)
}

func (fake *FakeTarget) TLSConfigReturns(result1 *tls.Config) {
	fake.TLSConfigStub = nil
	fake.tLSConfigReturns = struct {
		result1 *tls.Config
	}{result1}
}

func (fake *FakeTarget) URL() string {
	fake.uRLMutex.Lock()
	fake.uRLArgsForCall = append(fake.uRLArgsForCall, struct{}{})
	fake.recordInvocation("URL", []interface{}{})
	fake.uRLMutex.Unlock()
	if fake.URLStub != nil {
		return fake.URLStub()
	} else {
		return fake.uRLReturns.result1
	}
}

func (fake *FakeTarget) URLCallCount() int {
	fake.uRLMutex.RLock()
	defer fake.uRLMutex.RUnlock()
	return len(fake.uRLArgsForCall)
}

func (fake *FakeTarget) URLReturns(result1 string) {
	fake.URLStub = nil
	fake.uRLReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTarget) Token() *rc.TargetToken {
	fake.tokenMutex.Lock()
	fake.tokenArgsForCall = append(fake.tokenArgsForCall, struct{}{})
	fake.recordInvocation("Token", []interface{}{})
	fake.tokenMutex.Unlock()
	if fake.TokenStub != nil {
		return fake.TokenStub()
	} else {
		return fake.tokenReturns.result1
	}
}

func (fake *FakeTarget) TokenCallCount() int {
	fake.tokenMutex.RLock()
	defer fake.tokenMutex.RUnlock()
	return len(fake.tokenArgsForCall)
}

func (fake *FakeTarget) TokenReturns(result1 *rc.TargetToken) {
	fake.TokenStub = nil
	fake.tokenReturns = struct {
		result1 *rc.TargetToken
	}{result1}
}

func (fake *FakeTarget) TokenAuthorization() (string, bool) {
	fake.tokenAuthorizationMutex.Lock()
	fake.tokenAuthorizationArgsForCall = append(fake.tokenAuthorizationArgsForCall, struct{}{})
	fake.recordInvocation("TokenAuthorization", []interface{}{})
	fake.tokenAuthorizationMutex.Unlock()
	if fake.TokenAuthorizationStub != nil {
		return fake.TokenAuthorizationStub()
	} else {
		return fake.tokenAuthorizationReturns.result1, fake.tokenAuthorizationReturns.result2
	}
}

func (fake *FakeTarget) TokenAuthorizationCallCount() int {
	fake.tokenAuthorizationMutex.RLock()
	defer fake.tokenAuthorizationMutex.RUnlock()
	return len(fake.tokenAuthorizationArgsForCall)
}

func (fake *FakeTarget) TokenAuthorizationReturns(result1 string, result2 bool) {
	fake.TokenAuthorizationStub = nil
	fake.tokenAuthorizationReturns = struct {
		result1 string
		result2 bool
	}{result1, result2}
}

func (fake *FakeTarget) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.clientMutex.RLock()
	defer fake.clientMutex.RUnlock()
	fake.teamMutex.RLock()
	defer fake.teamMutex.RUnlock()
	fake.cACertMutex.RLock()
	defer fake.cACertMutex.RUnlock()
	fake.validateMutex.RLock()
	defer fake.validateMutex.RUnlock()
	fake.validateWithWarningOnlyMutex.RLock()
	defer fake.validateWithWarningOnlyMutex.RUnlock()
	fake.tLSConfigMutex.RLock()
	defer fake.tLSConfigMutex.RUnlock()
	fake.uRLMutex.RLock()
	defer fake.uRLMutex.RUnlock()
	fake.tokenMutex.RLock()
	defer fake.tokenMutex.RUnlock()
	fake.tokenAuthorizationMutex.RLock()
	defer fake.tokenAuthorizationMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeTarget) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ rc.Target = new(FakeTarget)
